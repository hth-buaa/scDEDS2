#' @title Optimize Regulatory Strength Parameter (theta) for TG-TF Pair
#'
#' @description
#' This function optimizes the regulatory strength parameter (theta) for a specific target gene-transcription factor (TG-TF) pair using trained model parameters.
#' It employs the Brent optimization method to find the theta value that minimizes the prediction error for expression dynamics across multiple time points.
#'
#' @param data See in ?loss_cal.
#' @param best_params Numeric vector. Optimized model parameters obtained from previous training, typically generated by gradient ascent optimization.
#' @param params_names See in ?f_train_cal.
#' @param tao See in ?f_train_cal.
#' @param Tslot_K See in ?f_train_cal.
#'
#' @returns
#' A numeric value representing the optimized regulatory strength parameter (theta) that minimizes the prediction error for the given TG-TF pair.
#' The value is constrained between 0.01 and 0.99.
#'
#' @details
#' The function performs the following optimization process:
#' \enumerate{
#' \item Expression Data Extraction: Retrieves TFE, TGA, and TGE time series data
#' \item Using \code{R_cal}
#' \item Parameter Retrieval: Extracts all relevant model parameters for the TG-TF pair
#' \item Hill Function Applications: Computes multiple Hill functions for regulatory components
#' \item Objective Function: Calculates mean squared prediction errors across time points
#' \item Optimization: Uses Brent's method to find theta that minimizes the objective function
#' }
#' The optimization is constrained to theta values between 0.01 and 0.99 to ensure biological plausibility and numerical stability.
#'
#' @note
#' Important considerations:
#' \itemize{
#' \item The function assumes the input parameters are from a previously trained model
#' \item Optimization uses Brent's method which is efficient for 1-dimensional problems
#' \item The TG-TF identifier must follow the specific format for proper parsing
#' \item The data parameter must contain the required expression time series
#' \item The function is typically used for fine-tuning regulatory strength in validated models
#' }
#'
#' @seealso \code{\link{optim}}, \code{\link{R_cal}}, \code{\link{Hill_cal}}, \code{\link{S_cal}}
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # The settings for the other parameters are inside the function scDEDS::model_train.
#' print(theta_p_cal(
#'   data = train_data,
#'   best_params = best_params,
#'   params_names = params_names,
#'   tao = tao,
#'   Tslot_K = Tslot_K
#' ))
#' }
theta_p_cal = function (data = train_data,
                        best_params = best_params,
                        params_names = params_names,
                        tao = tao,
                        Tslot_K = Tslot_K)
{
  pa_best = base::as.numeric(best_params)
  base::names(pa_best) = params_names
  stats::optim(par = tao, fn = function(theta) {
    TFE = base::as.numeric(data[, base::grep("TFE_", base::colnames(data), value = TRUE)])
    TGA = base::as.numeric(data[, base::grep("TGA_", base::colnames(data), value = TRUE)])
    TGE = base::as.numeric(data[, base::grep("TGE_", base::colnames(data), value = TRUE)])
    Length = base::length(TFE)
    seqLength = base::seq_len(Length - 1)
    R = scDEDS::R_cal(
      theta_TF_TG = theta,
      tao = tao,
      r1 = 200,
      r2 = (pa_best["r.r2_TG"] + pa_best["r.r2_TF"])/2,
      r3 = 1,
      r4 = 1000,
      r5 = 1
    )
    alpha1 = (pa_best[base::paste0("alpha.alpha1_TG_K-1.", seqLength)] + pa_best[base::paste0("alpha.alpha1_TF_K-1.", seqLength)])/2
    alpha2 = (pa_best[base::paste0("alpha.alpha2_TG_K-1.", seqLength)] + pa_best[base::paste0("alpha.alpha2_TF_K-1.", seqLength)])/2
    beta1 = (pa_best[base::paste0("beta.beta1_TG_K-1.", seqLength)] + pa_best[base::paste0("beta.beta1_TF_K-1.", seqLength)])/2
    beta2 = (pa_best[base::paste0("beta.beta2_TG_K-1.", seqLength)] + pa_best[base::paste0("beta.beta2_TF_K-1.", seqLength)])/2
    beta3 = pa_best[base::paste0("beta.beta3_TG_K-1.", seqLength)]
    s1 = (pa_best["s.s1_TG"] + pa_best["s.s1_TF"])/2
    s2 = (pa_best["s.s2_TG"] + pa_best["s.s2_TF"])/2
    u11 = pa_best["u.u11_TG"]
    u21 = pa_best["u.u21_TG"]
    u311 = pa_best["u.u311_TG"]
    u321 = pa_best["u.u321_TG"]
    u331 = pa_best["u.u331_TG"]
    u12 = pa_best["u.u12_TG"]
    u22 = pa_best["u.u22_TG"]
    u312 = pa_best["u.u312_TG"]
    u322 = pa_best["u.u322_TG"]
    u332 = pa_best["u.u332_TG"]
    TGE_tilde = pa_best[base::paste0("E~.E~_TG_K-1.", seqLength)]
    TFE_tilde = pa_best[base::paste0("E~.E~_TF_K-1.", seqLength)]
    U1_tilde = scDEDS::Hill_cal(x = TGE_tilde, Dissociation_Constant = u11, Hill_Coefficient = u12)
    U2_tilde = scDEDS::Hill_cal(x = TFE_tilde, Dissociation_Constant = u21, Hill_Coefficient = u22)
    U1 = scDEDS::Hill_cal(x = TGE[-Length], Dissociation_Constant = u11, Hill_Coefficient = u12)
    U2 = scDEDS::Hill_cal(x = TFE[-Length], Dissociation_Constant = u21, Hill_Coefficient = u22)
    U31 = scDEDS::Hill_cal(x = TGA[-Length], Dissociation_Constant = u311, Hill_Coefficient = u312)
    U32 = scDEDS::Hill_cal(x = TGE[-Length], Dissociation_Constant = u321, Hill_Coefficient = u322)
    U33 = scDEDS::Hill_cal(x = TGE_tilde[-Length], Dissociation_Constant = u331, Hill_Coefficient = u332)
    v1 = pa_best["v.v1_TG"]
    v2 = pa_best["v.v2_TG"]
    v3 = pa_best["v.v3_TG"]
    base::sum(base::sapply(2:Length, function(K) {
      prev_idx = K - 1
      2 * (TFE[prev_idx] + alpha1[prev_idx] * R * scDEDS::S_cal(s = s1, U = U1[prev_idx], U_tilde = U1_tilde[prev_idx]) + beta1[prev_idx] - TFE[K])^2 +
        2 * (TGA[prev_idx] + alpha2[prev_idx] * R * scDEDS::S_cal(s = s2, U = U2[prev_idx], U_tilde = U2_tilde[prev_idx]) + beta2[prev_idx] - TGA[K])^2 +
        (TGE[prev_idx] + R * (v1 * U31[prev_idx] - v2 * U32[prev_idx] - v3 * U33[prev_idx]) * Tslot_K[K] + beta3[prev_idx] - TGE[K])^2
    }))
  }, lower = 0.01, upper = 0.99, method = "Brent")$par
}
